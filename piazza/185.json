{
  "status": "active", 
  "unique_views": 145, 
  "request_instructor_me": false, 
  "change_log": [
    {
      "type": "create", 
      "anon": "no", 
      "when": "2017-09-04T22:39:47Z", 
      "data": "j76r1084wl37he", 
      "uid": "ijbr5ddtwyt6pa"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-09-04T22:40:24Z", 
      "data": "j76r1slbx3nfi", 
      "uid": "ijbr5ddtwyt6pa"
    }, 
    {
      "uid": "i4nkipeofrkrz", 
      "type": "s_answer", 
      "when": "2017-09-04T22:57:58Z", 
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "data": "j76rodga1661gl"
    }, 
    {
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "when": "2017-09-05T01:58:26Z", 
      "type": "followup", 
      "uid": "i4j6x5bv5ua71n"
    }, 
    {
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "when": "2017-09-05T03:03:07Z", 
      "type": "feedback", 
      "uid": "i4ket0u1z5q31a"
    }, 
    {
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "when": "2017-09-05T13:55:49Z", 
      "type": "followup", 
      "uid": "hqa65fnalg83fr"
    }, 
    {
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "when": "2017-09-05T13:59:27Z", 
      "type": "feedback", 
      "uid": "hqa65fnalg83fr"
    }, 
    {
      "to": "j76r1081v4w7hd", 
      "anon": "no", 
      "when": "2017-09-08T22:09:22Z", 
      "type": "feedback", 
      "uid": "i4ket0u1z5q31a"
    }
  ], 
  "upvote_ids": [], 
  "id": "j76r1081v4w7hd", 
  "bookmarked": 5, 
  "no_answer": 0, 
  "i_edits": [], 
  "is_bookmarked": false, 
  "children": [
    {
      "folders": [], 
      "is_tag_endorse": false, 
      "created": "2017-09-04T22:57:58Z", 
      "type": "s_answer", 
      "tag_endorse_arr": [
        "ijbr5ddtwyt6pa"
      ], 
      "id": "j76rodg6szo1gk", 
      "bucket_name": "Today", 
      "config": {}, 
      "tag_endorse": [
        {
          "name": "Jason Buoni", 
          "admin": false, 
          "photo": "1463440659_35.png", 
          "us": false, 
          "role": "student", 
          "facebook_id": null, 
          "id": "ijbr5ddtwyt6pa"
        }
      ], 
      "bucket_order": 2, 
      "data": {
        "embed_links": []
      }, 
      "children": [], 
      "history": [
        {
          "content": "<p>The small increments don&#39;t really matter for sufficiently large values of $$n$$. That&#39;s why the Big-O notation doesn&#39;t account for them.</p>\n<p></p>\n<ul><li>Think about n &#43; 1 iterations vs n - 1 iterations: for large enough values of n, that extra operation doesn&#39;t really matter (we assume the constant -- in this case 1 -- will always be smaller than n).</li><li>Think about\u00a0your second example: O(n) &#43; O(n) &#43; O(n^2): When n is large enough, the n^2 will be so large that the extra 2O(n) won&#39;t really account for anything.\u00a0</li></ul>\n<p></p>\n<p>Hopefully, this makes sense.</p>", 
          "anon": "no", 
          "created": "2017-09-04T22:57:58Z", 
          "uid": "i4nkipeofrkrz", 
          "subject": ""
        }
      ]
    }, 
    {
      "folders": [], 
      "updated": "2017-09-05T01:58:26Z", 
      "no_upvotes": 0, 
      "uid": "i4j6x5bv5ua71n", 
      "created": "2017-09-05T01:58:26Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j76y4gnnefon1", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-09-05T03:03:07Z", 
          "uid": "i4ket0u1z5q31a", 
          "created": "2017-09-05T03:03:07Z", 
          "type": "feedback", 
          "id": "j770fnfnpvk1x9", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Yes, for the purposes of the class the theoretical bounds are more important than practical optimization for small input sizes.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-05T13:59:27Z", 
          "uid": "hqa65fnalg83fr", 
          "created": "2017-09-05T13:59:27Z", 
          "type": "feedback", 
          "id": "j77nvpcpdwo5a6", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Constant times matter in the real world, but Big-O matters even more (usually).</p>\n<p></p>\n<p>You can beat out constant time by getting twice the processing power (hard these days), downloading a more optimized JVM, adding RAM, etc.. But you can get an O(N) down to O(1) in some cases and that will make things soooo much better. Usually.<br /><br />(Disclaimer: sometimes super duper algorithms have such high constants that they are impractical for data sizes often seen in the real world.. also Big-O can sometimes ignore things like Cache and RAM behavior that can affect your performance)</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-08T22:09:22Z", 
          "uid": "i4ket0u1z5q31a", 
          "created": "2017-09-08T22:09:22Z", 
          "type": "feedback", 
          "id": "j7cfpa8ip8o2rw", 
          "anon": "no", 
          "bucket_name": "Today", 
          "config": {}, 
          "bucket_order": 2, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>I think we&#39;re talking about the cases where the input is small and the setup cost of a super duper algorithm is greater than the overall cost of a technically inferior algorithm when applied to a small dataset.</p>\n<p>A trivial example was given in the lectures where for N &lt;= 5 the inefficient algorithm performed better.\u00a0 If you know that your real world data set sizes put you into that kind of a situation then you might actually want to ignore the O(.) costs and go with the execution timings, memory overhead, etc. instead.</p>\n<p></p>"
        }
      ], 
      "subject": "In the real world, constant factors absolutely do matter. If something takes 30 seconds to display to the user, or to finish processing, reducing that by half is a great result. Big O is meant to convey how performance scales with the size of the input, which is certainly useful for understanding how an algorithm behaves with different inputs, but doesn&#39;t indicate how long it will take in the real world. \n\nThat being said, I&#39;d assume that only performance relative to input size  (Big O) is relevant to the class"
    }, 
    {
      "folders": [], 
      "updated": "2017-09-05T13:55:49Z", 
      "no_upvotes": 0, 
      "uid": "hqa65fnalg83fr", 
      "created": "2017-09-05T13:55:49Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j77nr19s71o38v", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [], 
      "subject": "<p>Yeah.. think of linear growth (O(N)) as if you double the input the time will double.</p>\n<p></p>\n<p>But quadratic growth (O(N^2)) means that if you double the input the time will increase by the amount squared.<br /><br />So if the initial time was 10, then with linear it will take time 20.<br />But with quadratic it will take 400.<br /><br />Big-O \u00a0 \u00a0 T \u00a0 \u00a0 \u00a0 \u00a02T \u00a0 \u00a0 \u00a0 \u00a0 1000T \u00a0 \u00a0\u00a0<br />N \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 10 \u00a0 \u00a0 \u00a0 20 \u00a0 \u00a0 \u00a0 \u00a0 \u00a02000 \u00a0 \u00a0 \u00a0\u00a0</p>\n<p>N^2 \u00a0 \u00a0 \u00a0 10 \u00a0 \u00a0 400 \u00a0 \u00a04000000 \u00a0 \u00a0 \u00a0\u00a0<br /><br />So your linear for loop will increase to 20, but your quadratic double loop will increase to 400. As N goes to infinity this becomes so dramatic that the linear loop no longer matters.<br /><br />For example if 10 becomes 1000, then the linear loop takes 2000 time. But the quadratic is now 4 000 000.<br />So as you see the quadratic time TOTALLY dominates the linear as it grows, the linear loop just becomes negligible noise in your runtime.\u00a0<br /><br />For double time linear was 5% of quadratic. But for 1000 times linear is 0.05% of quadratic. So you can safely ignore its influence on the runtime as N tends to infinity.</p>"
    }
  ], 
  "nr": 185, 
  "bucket_order": 2, 
  "type": "question", 
  "folders": [
    "dynamic_programming", 
    "dp-solutions"
  ], 
  "no_answer_followup": 0, 
  "num_favorites": 1, 
  "bucket_name": "Today", 
  "q_edits": [], 
  "data": {
    "embed_links": []
  }, 
  "request_instructor": 0, 
  "tags": [
    "dp-solutions", 
    "dynamic_programming", 
    "student"
  ], 
  "created": "2017-09-04T22:39:47Z", 
  "is_tag_good": false, 
  "config": {}, 
  "s_edits": [], 
  "my_favorite": false, 
  "default_anonymity": "no", 
  "t": 1509145282328, 
  "tag_good": [], 
  "tag_good_arr": [], 
  "history": [
    {
      "content": "<p>Just wondering, for test cases, we only truly care about the O(v) correct? I.e. little things that could make it more efficient\u00a0are not as important.</p>\n<p></p>\n<p>For example, say we have something such as</p>\n<p></p>\n<p>T(i, 0) = 0</p>\n<p>T(0, j) = 0</p>\n<p>T(i, j) = 1 &#43; T(i-1, j&#43;1) .... //Doesn&#39;t really matter</p>\n<p></p>\n<p></p>\n<p>From a runtime perspective this is better:</p>\n<p></p>\n<pre>for i = 1 -&gt; n\n\u00a0 \u00a0 T(i, 0) = 0\n\u00a0 \u00a0 for j = 1 -&gt; n\n\u00a0 \u00a0 \u00a0 T(0, j) = 0<br />      //Do your stuff here\n\u00a0 \u00a0end\nend</pre>\n<p>but instead we are seeing some examples such as:</p>\n<p></p>\n<pre>for i = 1 -&gt; n\n\u00a0 \u00a0 T(i, 0) = 0\nend\nfor j = 1 -&gt; n\n\u00a0 \u00a0T(0, j) = 0\nend\nfor i = 1 -&gt; n\n\u00a0 \u00a0 T(i, 0) = 0\n\u00a0 \u00a0 for j = 1 -&gt; n\n\u00a0 \u00a0 \u00a0 T(0, j) = 0<br />      //Do your stuff here\n\u00a0 \u00a0end\nend</pre>\n<p>Now, both have the same O(n^2) correct? But one is actually better from a performance perspective because we run through n 2 less times, so if n is a massive number, we skip that calculation.\u00a0</p>\n<p></p>\n<p>Does DP have an opinion on this? Or from does it consider these cases equal in terms of how\u00a0efficient they are?</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>", 
      "anon": "no", 
      "created": "2017-09-04T22:40:24Z", 
      "uid": "ijbr5ddtwyt6pa", 
      "subject": "True &#34;Efficiency&#34;"
    }, 
    {
      "content": "<p>Just wondering, for test cases, we only truly care about the O(v) correct? I.e. little things that could make it more efficient\u00a0are not as important.</p>\n<p></p>\n<p>For example, say we have something such as</p>\n<p></p>\n<p>T(i, 0) = 0</p>\n<p>T(0, j) = 0</p>\n<p>T(i, j) = 1 &#43; T(i-1, j&#43;1) .... //Doesn&#39;t really matter</p>\n<p></p>\n<p></p>\n<p>From a runtime perspective this is better:</p>\n<p></p>\n<pre>for i = 1 -&gt; n<br />\u00a0 \u00a0 T(i, 0) = 0<br />\u00a0 \u00a0 for j = 1 -&gt; n<br />\u00a0 \u00a0 \u00a0 T(0, j) = 0<br />\u00a0 \u00a0end<br />end</pre>\n<p>but instead we are seeing some examples such as:</p>\n<p></p>\n<pre>for i = 1 -&gt; n<br />\u00a0 \u00a0 T(i, 0) = 0<br />end<br />for j = 1 -&gt; n<br />\u00a0 \u00a0T(0, j) = 0<br />end<br />for i = 1 -&gt; n<br />\u00a0 \u00a0 T(i, 0) = 0<br />\u00a0 \u00a0 for j = 1 -&gt; n<br />\u00a0 \u00a0 \u00a0 T(0, j) = 0<br />\u00a0 \u00a0end<br />end</pre>\n<p>Now, both have the same O(n^2) correct? But one is actually better from a performance perspective because we run through n 2 less times, so if n is a massive number, we skip that calculation.\u00a0</p>\n<p></p>\n<p>Does DP have an opinion on this? Or from does it consider these cases equal in terms of how\u00a0efficient they are?</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>", 
      "anon": "no", 
      "created": "2017-09-04T22:39:47Z", 
      "uid": "ijbr5ddtwyt6pa", 
      "subject": "True &#34;Efficiency&#34;"
    }
  ]
}