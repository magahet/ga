{
  "status": "active", 
  "unique_views": 121, 
  "request_instructor_me": false, 
  "change_log": [
    {
      "type": "create", 
      "anon": "no", 
      "when": "2017-09-07T03:14:06Z", 
      "data": "j79vph964nd4ov", 
      "uid": "hz0pec4uduL"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-07T03:26:23Z", 
      "type": "followup", 
      "uid": "i4iys7m3lpq2ij"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-08T02:21:25Z", 
      "type": "feedback", 
      "uid": "hz0pec4uduL"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-08T15:16:55Z", 
      "type": "feedback", 
      "uid": "i4iys7m3lpq2ij"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-12T04:09:05Z", 
      "type": "feedback", 
      "uid": "hz0pec4uduL"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-12T13:19:06Z", 
      "type": "feedback", 
      "uid": "i4iys7m3lpq2ij"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-13T04:12:11Z", 
      "type": "feedback", 
      "uid": "hz0pec4uduL"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-19T23:24:56Z", 
      "type": "feedback", 
      "uid": "hq8hn0qyfuvyr"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-19T23:25:37Z", 
      "type": "feedback", 
      "uid": "hq8hn0qyfuvyr"
    }, 
    {
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "when": "2017-09-19T23:29:07Z", 
      "type": "feedback", 
      "uid": "hq8hn0qyfuvyr"
    }, 
    {
      "uid": "i4iys7m3lpq2ij", 
      "type": "s_answer", 
      "when": "2017-09-26T13:45:58Z", 
      "to": "j79vph95bfo4ou", 
      "anon": "no", 
      "data": "j81nn93qehi3ue"
    }
  ], 
  "upvote_ids": [], 
  "id": "j79vph95bfo4ou", 
  "bookmarked": 5, 
  "no_answer": 0, 
  "i_edits": [], 
  "is_bookmarked": false, 
  "children": [
    {
      "folders": [], 
      "updated": "2017-09-07T03:26:23Z", 
      "no_upvotes": 0, 
      "uid": "i4iys7m3lpq2ij", 
      "created": "2017-09-07T03:26:23Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j79w59jrxt713f", 
      "anon": "no", 
      "bucket_name": "Week 9/3 - 9/9", 
      "config": {}, 
      "bucket_order": 8, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-09-08T02:21:25Z", 
          "uid": "hz0pec4uduL", 
          "created": "2017-09-08T02:21:25Z", 
          "type": "feedback", 
          "id": "j7b99ksjr6b4pc", 
          "anon": "no", 
          "bucket_name": "Week 9/3 - 9/9", 
          "config": {}, 
          "bucket_order": 8, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Thanks Kate. I&#39;d looked at some lecture notes with a solution to the 2 partition problem earlier this week (see <a href=\"http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp3.pdf\">http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp3.pdf</a>). The table is T(i) = does a partition exist that equals the sum i. The recurrence is a bit different than we&#39;ve done in class. It is something like T(xi&#43;T(k)) = 1 for k = 1..n.\u00a0</p>\n<p></p>\n<p>Since there are only two sets for two partitions, knowing that a set of N/2 can be formed automatically solves the problem. However, knowing that a set of N/3 can be formed does not solve three partition because it is necessary to validate that another set of N/3 can be formed without elements in the first N/3 set. I&#39;m starting to think that the solution might be to track the elements that make up a given sum in the table. I might give that a try.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-08T15:16:55Z", 
          "uid": "i4iys7m3lpq2ij", 
          "created": "2017-09-08T15:16:55Z", 
          "type": "feedback", 
          "id": "j7c0yvty7j74to", 
          "anon": "no", 
          "bucket_name": "Week 9/3 - 9/9", 
          "config": {}, 
          "bucket_order": 8, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>You&#39;re on the right path, I think. Consider how you &#34;tracked&#34; elements in knapsack without repetition. Also, think about how, in the 2-partition problem,\u00a0if one set sums to $$\\frac{ \\sum_{i=1}^n a_i}{2}$$ then the remaining set also sums to\u00a0$$\\frac{ \\sum_{i=1}^n a_i}{2}$$. For the 3-partition problem, it&#39;s sufficient to know that we have two sets that sum to\u00a0$$\\frac{ \\sum_{i=1}^n a_i}{3}$$, right?</p>\n<p></p>\n<p>Incidentally, I find the 2-partition solution you posted a bit difficult to follow. The natural approach, in my mind, is the same as for 6.18 if you were to set\u00a0$$v=\\frac{ \\sum_{i=1}^n x_i}{2}$$.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-12T04:09:05Z", 
          "uid": "hz0pec4uduL", 
          "created": "2017-09-12T04:09:05Z", 
          "type": "feedback", 
          "id": "j7h2vgczuml6oy", 
          "anon": "no", 
          "bucket_name": "Week 9/10 - 9/16", 
          "config": {}, 
          "bucket_order": 7, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Thanks Kate. I think I figured it out.\u00a0</p>\n<p></p>\n<p>The table is the same as knapsack:</p>\n<p>T(b, i) -&gt; The maximum capacity up to amount b with items 1..i</p>\n<p></p>\n<p>The recurrence is also the same as knapsack:\u00a0</p>\n<p>T(b, i) = max(T(b-x_i, I-1), T(b-x_i, I-1)) if x_i &lt;= b</p>\n<p>T(b, i) = T(b, I-i) if x_1 &gt; b</p>\n<p></p>\n<p>Let v = sum(items)/k</p>\n<p>The key is to run knapsack for b &lt;= k. Then run a final iteration at k to count the possible partitions of size v. If there are more than two partitions of size v, then the set can be broken into k partitions.</p>\n<p></p>\n<p>The pseudo code is:</p>\n<p></p>\n<p>Initialize T(b,0) and T(0,i) to 0</p>\n<p>v = sum(items)/k (k is the number of desired partitions)</p>\n<p>for b = 1..v-1:</p>\n<p>\u00a0 \u00a0for i = 1..n:</p>\n<p>\u00a0 \u00a0 \u00a0 if x_i &lt; b:</p>\n<p>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0T[b,i] = max(T[b-x_i, i-1] &#43; x_i, T[b, i-1])</p>\n<p>\u00a0 \u00a0 \u00a0 else:</p>\n<p>\u00a0 \u00a0 \u00a0 \u00a0 \u00a0T[b,i] = T[b, i-1]</p>\n<p>z = 0</p>\n<p>for i = 1..n:</p>\n<p>\u00a0 \u00a0if T[v - x_i, i-1] &#43; x_i = v:</p>\n<p>\u00a0 \u00a0 \u00a0 z&#43;&#43;</p>\n<p>if z &gt; k:</p>\n<p>\u00a0 \u00a0 return True</p>\n<p>else:</p>\n<p>\u00a0 \u00a0 return False</p>\n<p></p>\n<p>Except for the last loop the algorithm is almost identical to knapsack without replacement. One issue I see is that the problem in the book asks for an algorithm that is polynomial in n, whereas knapsack is exponential in n.</p>\n<p></p>\n<p>Does anyone have any ideas for getting to a polynomial algorithm.</p>\n<p></p>\n<p></p>\n<p></p>\n<p></p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-12T13:19:06Z", 
          "uid": "i4iys7m3lpq2ij", 
          "created": "2017-09-12T13:19:06Z", 
          "type": "feedback", 
          "id": "j7hmirgzcht6rq", 
          "anon": "no", 
          "bucket_name": "Week 9/10 - 9/16", 
          "config": {}, 
          "bucket_order": 7, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>I don&#39;t think you&#39;ve quite got it as I don&#39;t think the last loop ensures disjoint\u00a0subsets. I used a 3D table and my solution does not generalize to any k.</p>\n<p></p>\n<p>As far as runtime, knapsack is exponential in B, not n.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-13T04:12:11Z", 
          "uid": "hz0pec4uduL", 
          "created": "2017-09-13T04:12:11Z", 
          "type": "feedback", 
          "id": "j7iifajrbdx77n", 
          "anon": "no", 
          "bucket_name": "Week 9/10 - 9/16", 
          "config": {}, 
          "bucket_order": 7, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Thanks Kate. I&#39;ll have to continue thinking about this one. Thanks for pointing out that knapsack is exponential in B....I rewatched the lecture this evening and I understand why that is now.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-19T23:24:56Z", 
          "uid": "hq8hn0qyfuvyr", 
          "created": "2017-09-19T23:24:56Z", 
          "type": "feedback", 
          "id": "j7s88u8t3ca3rw", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>&#64;Hugh, you mentioned that an algorithm for knapsack is exponential in <em>n</em>. That is true for a brute-force algorithm. Perhaps that&#39;s what you&#39;re referring to.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-19T23:25:37Z", 
          "uid": "hq8hn0qyfuvyr", 
          "created": "2017-09-19T23:25:37Z", 
          "type": "feedback", 
          "id": "j7s89q056yn49m", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p><a href=\"http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp3.pdf\">http://www.cs.cornell.edu/~wdtseng/icpc/notes/dp3.pdf</a>\u00a0has some nice touches. In particular, he incorporated forgetting rows of the table that are no longer useful. So when he updates the table for item <em>i</em>, he is, at the same time, &#34;forgetting&#34; what&#39;s true for <em>i-1</em>. That&#39;s why he has to update the row from right to left. I think that other than that optimization and one or two other optimizations, his approach is the same as that used for DPV 6.18.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-09-19T23:29:07Z", 
          "uid": "hq8hn0qyfuvyr", 
          "created": "2017-09-19T23:29:07Z", 
          "type": "feedback", 
          "id": "j7s8e83msbt7fv", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>&#64;Kate, you mention that your solution doesn&#39;t generalize to any k. I was thinking that mine does. However, on second thought, I have to be more specific. Now that I know how to solve it for 3 partitions, I think I know how to solve it for any other number. But, it&#39;s not as though my algorithm could solve it for 4 partitions at the same cost.</p>"
        }
      ], 
      "subject": "<p>Have you solved the 2-partition problem? I thought that was a good starting point. Then you think about how to extend to 3 partitions.</p>"
    }, 
    {
      "folders": [], 
      "is_tag_endorse": false, 
      "created": "2017-09-26T13:45:58Z", 
      "type": "s_answer", 
      "tag_endorse_arr": [], 
      "id": "j81nn92wand3ud", 
      "bucket_name": "Today", 
      "config": {}, 
      "tag_endorse": [], 
      "bucket_order": 2, 
      "data": {
        "embed_links": []
      }, 
      "children": [], 
      "history": [
        {
          "content": "<p>Marking as resolved, see discussion below.</p>", 
          "anon": "no", 
          "created": "2017-09-26T13:45:58Z", 
          "uid": "i4iys7m3lpq2ij", 
          "subject": ""
        }
      ]
    }
  ], 
  "nr": 211, 
  "bucket_order": 2, 
  "type": "question", 
  "folders": [
    "dynamic_programming"
  ], 
  "no_answer_followup": 0, 
  "num_favorites": 3, 
  "bucket_name": "Today", 
  "q_edits": [], 
  "data": {
    "embed_links": []
  }, 
  "request_instructor": 0, 
  "tags": [
    "dynamic_programming", 
    "student"
  ], 
  "created": "2017-09-07T03:14:06Z", 
  "is_tag_good": false, 
  "config": {}, 
  "s_edits": [], 
  "my_favorite": false, 
  "default_anonymity": "no", 
  "t": 1509145274194, 
  "tag_good": [], 
  "tag_good_arr": [], 
  "history": [
    {
      "content": "<p>I&#39;ve been working on the three partition problem (6.25) in DPV for some extra DP practice, but I&#39;m stuck on it.\u00a0</p>\n<p></p>\n<p>Here is what I&#39;ve figured out so far (which isn&#39;t much).</p>\n<ul><li>There need to be three partitions that each sum to a1, a2.....an/n</li><li>A given item can go into one of three partition</li></ul>\n<p></p>\n<p>I&#39;m stuck on figuring out the recurrence and wondering if someone could give me a hint that might point me in the right direction.</p>", 
      "anon": "no", 
      "created": "2017-09-07T03:14:06Z", 
      "uid": "hz0pec4uduL", 
      "subject": "3 partition DP problem"
    }
  ]
}