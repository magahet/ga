{
  "status": "active", 
  "unique_views": 148, 
  "request_instructor_me": false, 
  "change_log": [
    {
      "type": "create", 
      "anon": "no", 
      "when": "2017-10-24T12:57:23Z", 
      "data": "j95m8mg9f6syr", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:15:52Z", 
      "type": "followup", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:20:29Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:40:13Z", 
      "type": "followup", 
      "uid": "ijarmqggjkc3gz"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:42:49Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:44:23Z", 
      "type": "feedback", 
      "uid": "i8597yy2i2f1z6"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T13:51:58Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:00:12Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:02:22Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:08:19Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:12:41Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:16:46Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:21:03Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "uid": "i4hdvab632i522", 
      "type": "s_answer", 
      "when": "2017-10-24T14:25:43Z", 
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "data": "j95pe7z9xlk2t8"
    }, 
    {
      "type": "s_answer_update", 
      "anon": "no", 
      "when": "2017-10-24T14:27:11Z", 
      "data": "j95pg3rrjoy484", 
      "uid": "i4hdvab632i522"
    }, 
    {
      "type": "s_answer_update", 
      "anon": "no", 
      "when": "2017-10-24T14:28:44Z", 
      "data": "j95pi3ncjgm5pc", 
      "uid": "i4hdvab632i522"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:46:39Z", 
      "type": "followup", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:49:21Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:49:28Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:50:29Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T14:54:54Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T15:00:11Z", 
      "type": "feedback", 
      "uid": "i4hdvab632i522"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-24T15:01:24Z", 
      "type": "feedback", 
      "uid": "i8597qyse9c1v2"
    }, 
    {
      "uid": "gy4twfv45cg5o6", 
      "type": "i_answer", 
      "when": "2017-10-25T00:31:28Z", 
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "data": "j96b182rcnor"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-25T18:58:06Z", 
      "type": "followup", 
      "uid": "ij9b2ekdTWF"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-25T19:07:04Z", 
      "type": "feedback", 
      "uid": "ij9b2ekdTWF"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-25T22:27:04Z", 
      "type": "feedback", 
      "uid": "ij9b2ekdTWF"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-25T23:36:47Z", 
      "type": "feedback", 
      "uid": "hq8hn0qyfuvyr"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-26T14:56:44Z", 
      "type": "followup", 
      "uid": "gy4twfv45cg5o6"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-26T15:09:09Z", 
      "type": "feedback", 
      "uid": "hvil6y6khgk2ri"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-26T15:19:07Z", 
      "type": "feedback", 
      "uid": "ij9b2ekdTWF"
    }, 
    {
      "to": "j95m8mg67i2yp", 
      "anon": "no", 
      "when": "2017-10-26T15:24:12Z", 
      "type": "feedback", 
      "uid": "gy4twfv45cg5o6"
    }
  ], 
  "upvote_ids": [], 
  "id": "j95m8mg67i2yp", 
  "bookmarked": 9, 
  "no_answer": 0, 
  "i_edits": [], 
  "is_bookmarked": false, 
  "children": [
    {
      "folders": [], 
      "updated": "2017-10-24T13:15:52Z", 
      "no_upvotes": 0, 
      "uid": "hvil6y6khgk2ri", 
      "created": "2017-10-24T13:15:52Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j95mwdze70d4tt", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-24T13:20:29Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T13:20:29Z", 
          "type": "feedback", 
          "id": "j95n2bsn23q4hp", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Doesn&#39;t cc greater than one just means that you called &#34;explore&#34; more than once in the DFS? I think if cc&gt;1, that means you would have created a disconnected undirected graph, is this not correct?</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T13:44:23Z", 
          "uid": "i8597yy2i2f1z6", 
          "created": "2017-10-24T13:44:23Z", 
          "type": "feedback", 
          "id": "j95nx2i1fuw6ar", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>If you call Explore from y (where e* = [y, z]) on the tree T without e*, you will find all of the edges that are in the path from y --&gt; z. Adding e* creates a cycle.</p>\n<p></p>\n<p>I did it the way where you create the cycle and then find the edges in that cycle. You can do this with Explore/DFS as well -- you are looking for backedges.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T13:51:58Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T13:51:58Z", 
          "type": "feedback", 
          "id": "j95o6tpgb322ga", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Right, adding e* creates a cycle, agreed. Running explore from y, will get you all vertices in the tree since the tree is completely connected?</p>\n<p></p>\n<p>Then how do you find the edges in that cycle without modifying the algorithm? At this point, we are talking about the question in the exam, which is, of course, related to my question in some way.</p>\n<p></p>\n<p>I agree that backedges\u00a0tell us about cycles, however, this is a undirected graph. The adjacency lists for a pair of vertices in an edge necessarily each contains one another.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:00:12Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-24T14:00:12Z", 
          "type": "feedback", 
          "id": "j95ohepuvgn773", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>cc = number of components in an undirected graph, regardless of where you start. cc only increments when whatever component you are in runs out of vertices to explore, indicating its done exploring whatever connected component its currently exploring.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:02:22Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T14:02:22Z", 
          "type": "feedback", 
          "id": "j95ok71kesy14v", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Agreed, but if all vertices are explored, then you can run out of vertices, and the algo\u00a0will simply exit. That does not seem to tell us anything about cycles, or maybe I am still not seeing the connection.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:08:19Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-24T14:08:19Z", 
          "type": "feedback", 
          "id": "j95orulhyn953i", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>I was assuming you were asking about how to find if an edge you added to a tree T after removing another edge made a cycle or not (I was anticipating this was a question about the test we just had). I wasnt completely sure thats what you were asking though, so I put this little note here instead of in the student answer section.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:12:41Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T14:12:41Z", 
          "type": "feedback", 
          "id": "j95oxgoxvua33g", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>To know if there is a cycle, we can just count the number of edges and vertices. For the exam question, adding any\u00a0one edge to the tree should create a cycle so we shouldn&#39;t need to check if there is a cycle. I still don&#39;t see how the component number of the graph relates in any way, maybe that&#39;s what I am not understanding.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:16:46Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-24T14:16:46Z", 
          "type": "feedback", 
          "id": "j95p2pmp7qj45h", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Hmmm, to answer your original question..... &#34;how can I output the vertices that form cycles in a undirected graph&#34;, if you are looking for the vertices that create a cycle - all vertices in a cycle - thats actually just running DFS and getting a list of all vertices grouped by cc number.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:21:03Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T14:21:03Z", 
          "type": "feedback", 
          "id": "j95p87g3rou2ci", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>A\u00a0fully connected graph with cycles or without cycles will have a cc number of 1 for its vertices no? That is, there is only one component (since the graph is fully connected), this is not a directed graph. The concept of strongly connected components does not hold here. Do I have this wrong?</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:49:28Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-24T14:49:28Z", 
          "type": "feedback", 
          "id": "j95q8r44dvn2dt", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>You are correct (but for an undirected graph I believe its still a cycle, even if there are n-1 edges, as you can get to anywhere from anywhere so long as you use the same edge back).</p>\n<p></p>\n<p>Basically: connected components are for <em>undirected</em> graphs.\u00a0 Strongly connected components are for <em>directed</em> graphs.</p>\n<p></p>\n<p>For undirected graphs, ccs basically tell you if the graph is disjoint (cc &gt; 1 its disjoint, cc=1 you can reach any vertex from any other vertex); the main point behind a CC for undirected graphs is to just let you know how disjoint the graph is, among other things (like if you can get from A to vertex B, and the only way that can happen in an undirected graph is if they are in the same component).</p>\n<p></p>\n<p>So take this undirected graph for example:</p>\n<p><img src=\"https://d1b10bmlvqabco.cloudfront.net/attach/j6f5zm92gj34gi/hvil6y6khgk2ri/j95q5sxab03w/ccnum_example.jpg\" alt=\"\" /></p>\n<p></p>\n<p>This is the result of runing DFS on this graph, and the ccnums it found (although ABC could have easily been ccnum=2 and D could have been ccnum = 1).\u00a0 Getting the CCnum on an undirected graph can tell you <br />A) how many ccs there are (sometimes you need to know if there is one or more than one)<br />B) which vertices are connected (in this case, its ABC thats connected in one (which is ALSO a cycle), and D &#39;connected&#39; in another).</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:50:29Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-24T14:50:29Z", 
          "type": "feedback", 
          "id": "j95qa2ofcgt380", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Keep in mind that <span style=\"text-decoration:underline\">an undirected graph does not have to connect all vertices</span> and the ccnum identifies &#39;other&#39; clusters that are not connected at all, as above; the above example is ONE graph (its not two) with two disjoint sections.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T14:54:54Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T14:54:54Z", 
          "type": "feedback", 
          "id": "j95qfqmy6v46y3", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Thanks Brent, you are right, ccnum\u00a0means number of components in a general undirected graph. My original question refers to a &#34;cycle&#34; within a fully connected graph (though I see how my question per say does not clarify that). But in the case of the exam question, we know we have a tree, so there is only one component. After adding the cycle edge, there will still be only one component.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-25T19:07:04Z", 
          "uid": "ij9b2ekdTWF", 
          "created": "2017-10-25T19:07:04Z", 
          "type": "feedback", 
          "id": "j97evw3rbyo4yk", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Edit: I originally posted this here but meant to post it in another thread.\u00a0 It doesn&#39;t really apply to this conversation, but I&#39;m leaving it here since it&#39;s mentioned in the student answer above.</p>\n<p></p>\n<p>Re: using DFS to find a path in max-flow - DFS tells us that a path from s to t <strong>exists</strong> in the residual graph, but it doesn&#39;t tell us exactly <strong>what that path is</strong>, right?\u00a0 In max-flow, we don&#39;t care what that path is - we just need to know that it exists.\u00a0 But in Exam 2 problem 2, we need to know what exactly the path is.\u00a0\u00a0We already know that there is a path from y to z in T, because it&#39;s a tree.\u00a0 A path necessarily exists.\u00a0 The questions is what is that path.</p>\n<p></p>\n<p>Edit: I take it back, we do need to know what the s-t path is in the residual graph, but I guess the details\u00a0for this\u00a0were\u00a0hand-waved as well... It still seems to me that DFS/Explore without modification return all nodes explored, not a specific path.</p>"
        }
      ], 
      "subject": "<p>Not 100% sure, but if you have a known tree T, you want to replace an edge with e*, but you dont know what edge to replace, you can replace any edge in the tree, and then run DFS on just the nodes in the tree using the edges defined in the tree; if the cc count &gt; 1, it means you have a cycle somewhere (although this doesnt tell you where that is, it just tells you it exists).</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-24T13:40:13Z", 
      "no_upvotes": 0, 
      "uid": "ijarmqggjkc3gz", 
      "created": "2017-10-24T13:40:13Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j95nrpr3j813t7", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-24T13:42:49Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T13:42:49Z", 
          "type": "feedback", 
          "id": "j95nv1pae5n3t9", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>You are correct. Having no cycle, I mean acyclic, as in the definition of the tree:</p>\n<p></p>\n<p><b>Tree</b>. A\u00a0<b>tree</b>\u00a0is an undirected graph G that satisfies any of the following equivalent conditions: G is connected and has no cycles. G is\u00a0<b>acyclic</b>, and a simple cycle is formed if any edge is added to G.</p>\n<p></p>\n<p></p>"
        }
      ], 
      "subject": "<p>You might need to be more precise about your definition of a cycle.\u00a0 If we use the same definition we&#39;ve been using for directed graphs then every undirected edge implicitly creates a cycle between the two vertices it strongly connects.\u00a0 My assumption is that you want to find cycles with a length greater or equal to 3.</p>"
    }, 
    {
      "folders": [], 
      "is_tag_endorse": false, 
      "created": "2017-10-24T14:25:43Z", 
      "type": "s_answer", 
      "tag_endorse_arr": [
        "i8597qyse9c1v2"
      ], 
      "id": "j95pe7z6vdm2t7", 
      "bucket_name": "Today", 
      "config": {}, 
      "tag_endorse": [
        {
          "name": "Pedro Henrique Rocha Moy", 
          "admin": false, 
          "photo": "1452626521_35.png", 
          "us": false, 
          "role": "student", 
          "facebook_id": null, 
          "id": "i8597qyse9c1v2"
        }
      ], 
      "bucket_order": 2, 
      "data": {
        "embed_links": []
      }, 
      "children": [], 
      "history": [
        {
          "content": "Referring specifically to the test question, it seems there are 2 principal alternatives\nAs a preliminary, you are given an edge $$(u,v)$$ that is part of the [only] cycle. So, remove the edge $$(u,v)$$ then look for the alternate path from $$u$$ to $$v$$, or from $$v$$ to $$u$$\n1) The use of DFS or BFS to locate a path in the residual graph for Max-Flow tends to suggest that both may be treated as algorithms that return a path without modification of the algorithm\n2) As that may sound marginally under-specified / a bit too hand-wavy: The implementation of DFS as described in DPV pages 84-87 includes pre- &amp; post-order numbers; so after conducting DFS [from $$u$$ assuming you were looking for a path from $$u$$ to $$v$$] sort the nodes according to their post-order numbers [$$O(n)$$ sort], then start from $$v$$ then ascertain its ancestors as the parents progressively according to the rule that pre(ancestor) &lt; pre(child) &lt; post(child) &lt; post(ancestor), while the parent is the most immediate ancestor in the sorted order, then eventually you&#39;ll reach $$u$$ that is of course the root of the DFS tree starting from $$u$$\n\nSaying that, we may discover that the &#39;find a cycle&#39; / &#39;find a path&#39; aspect is hand-waved a bit, so it may not matter all that much however you describe it :-D", 
          "anon": "no", 
          "created": "2017-10-24T14:28:44Z", 
          "uid": "i4hdvab632i522", 
          "subject": ""
        }, 
        {
          "content": "Referring specifically to the test question, it seems there are 2 principal alternatives\nAs a preliminary, you are given an edge $$(u,v)$$ that is part of the cycle. So, remove the edge $$(u,v)$$ then look for the alternate path from $$u$$ to $$v$$, or from $$v$$ to $$u$$\n1) The use of DFS or BFS to locate a path in the residual graph for Max-Flow tends to suggest that both may be treated as algorithms that return a path without modification of the algorithm\n2) As that may sound marginally under-specified / a bit too hand-wavy: The implementation of DFS as described in DPV pages 84-87 includes pre- &amp; post-order numbers; so after conducting DFS [from $$u$$ assuming you were looking for a path from $$u$$ to $$v$$] sort the nodes according to their post-order numbers [$$O(n)$$ sort], then start from $$v$$ then ascertain its ancestors as the parents progressively according to the rule that pre(ancestor) &lt; pre(child) &lt; post(child) &lt; post(ancestor), while the parent is the most immediate ancestor in the sorted order, then eventually you&#39;ll reach $$u$$ that is of course the root of the DFS tree starting from $$u$$\n\nSaying that, we may discover that the &#39;find a cycle&#39; / &#39;find a path&#39; aspect is hand-waved a bit, so it may not matter all that much however you describe it :-D", 
          "anon": "no", 
          "created": "2017-10-24T14:27:11Z", 
          "uid": "i4hdvab632i522", 
          "subject": ""
        }, 
        {
          "content": "Referring specifically to the test question, it seems there are 2 principal alternatives\nAs a preliminary, you are given an edge $$(u,v)$$ that is part of the cycle. So, remove the edge $$(u,v)$$ then look for the alternate path from $$u$$ to $$v$$, or from $$v$$ to $$u$$\n1) The use of DFS or BFS to locate a path in the residual graph for Max-Flow tends to suggest that both may be treated as algorithms that return a path without modification of the algorithm\n2) As that may sound marginally under-specified / a bit too hand-wavy: The implementation of DFS as described in DPV pages 84-87 includes pre- &amp; post-order numbers; so after conducting DFS, sort the nodes according to their post-order numbers [$$O(n)$$ sort], then, assuming you were looking for a path from $$u$$ to $$v$$, start from $$v$$ then ascertain its ancestors as the parents progressively according to the rule that pre(ancestor) &lt; pre(child) &lt; post(child) &lt; post(ancestor), while the parent is the most immediate ancestor in the sorted order, then eventually you&#39;ll reach $$u$$ that is of course the root of the DFS tree starting from $$u$$\n\nSaying that, we may discover that the &#39;find a cycle&#39; / &#39;find a path&#39; aspect is hand-waved a bit, so it may not matter all that much however you describe it :-D", 
          "anon": "no", 
          "created": "2017-10-24T14:25:43Z", 
          "uid": "i4hdvab632i522", 
          "subject": ""
        }
      ]
    }, 
    {
      "folders": [], 
      "updated": "2017-10-24T14:46:39Z", 
      "no_upvotes": 0, 
      "uid": "i8597qyse9c1v2", 
      "created": "2017-10-24T14:46:39Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j95q554zntl68p", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-24T14:49:21Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T14:49:21Z", 
          "type": "feedback", 
          "id": "j95q8lyh16q18v", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Yeah, actually, I am not sure we would collect only the vertices of the cycle, I think we could end up collecting vertices that do not belong to cycle;((</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T15:00:11Z", 
          "uid": "i4hdvab632i522", 
          "created": "2017-10-24T15:00:11Z", 
          "type": "feedback", 
          "id": "j95qmj6xhdf3mg", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "That&#39;s the reason the pre- &amp; post-order numbers both matter, with DFS, so that while iterating in order of increasing post-order numbers, you discard vertices that have pre(child) &lt; post(child) &lt; pre(potential) &lt; post(potential), that must be in a different branch of the DFS tree"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-24T15:01:24Z", 
          "uid": "i8597qyse9c1v2", 
          "created": "2017-10-24T15:01:24Z", 
          "type": "feedback", 
          "id": "j95qo43bh3a4jh", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Cool, let me ponder a bit about this. Thanks again;)</p>"
        }
      ], 
      "subject": "<p>Thanks\u00a0Mark! Because we know a priori we have a tree, and we know a priori the cycle edge, then now I can see how we can run BFS from one of the vertices of the cycle edge, and collect the path of vertices until we reach the other vertex. Effectively collecting the cycle edge.</p>\n<p></p>\n<p>It seems running DFS with pre and post numbers is still not helpful in my view as you can end up with the very same pre and post numbers for a small tree, and the cyclic graph. Well, this solves the question about the exam. I am still wondering about the original question;)</p>"
    }, 
    {
      "folders": [], 
      "is_tag_endorse": false, 
      "created": "2017-10-25T00:31:28Z", 
      "type": "i_answer", 
      "tag_endorse_arr": [
        "j8asouglzmcwj", 
        "hyywem7iw0v1jj"
      ], 
      "id": "j96b182qxg2oq", 
      "bucket_name": "Today", 
      "config": {}, 
      "tag_endorse": [
        {
          "name": "Arvind Kumar Sharma", 
          "admin": false, 
          "photo": "1508811058_35.png", 
          "us": false, 
          "role": "student", 
          "facebook_id": null, 
          "id": "j8asouglzmcwj"
        }, 
        {
          "name": "Babak Keyvani", 
          "admin": false, 
          "photo": "1408337737_35.png", 
          "us": false, 
          "role": "student", 
          "facebook_id": null, 
          "id": "hyywem7iw0v1jj"
        }
      ], 
      "bucket_order": 2, 
      "data": {
        "embed_links": []
      }, 
      "children": [], 
      "history": [
        {
          "content": "Sorry I didn&#39;t read all of the responses, but in case this helps:\n\nA tree T plus an edge e=(y,z) it contains a cycle C.  To find the cycle you can either:\n  -- Run Explore(y) on T to find the path P going from y--&gt;z and then $$P\\cup e$$ is C.\n  -- Run DFS or BFS on $$T\\cup e$$ and when you find the back edge you&#39;ll find the one cycle C in this graph.\n\nInteresting question: how long does it take to find this cycle in $$T\\cup e$$?\nYou&#39;re running DFS on a graph with (n-1)&#43;1 edges so it only takes O(n) time.  Hence problem 2 can be\ndone in O(n) time.   Noticing that the running time is O(n) instead of O(n&#43;m) or O(m) was the hardest part of the exam so don&#39;t worry if you didn&#39;t get it, almost all did not.", 
          "anon": "no", 
          "created": "2017-10-25T00:31:28Z", 
          "uid": "gy4twfv45cg5o6", 
          "subject": ""
        }
      ]
    }, 
    {
      "folders": [], 
      "updated": "2017-10-25T18:58:06Z", 
      "no_upvotes": 0, 
      "uid": "ij9b2ekdTWF", 
      "created": "2017-10-25T18:58:06Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j97ekd3p7zaw1", 
      "anon": "no", 
      "bucket_name": "This week", 
      "config": {}, 
      "bucket_order": 4, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-25T22:27:04Z", 
          "uid": "ij9b2ekdTWF", 
          "created": "2017-10-25T22:27:04Z", 
          "type": "feedback", 
          "id": "j97m13havq56eq", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Someone on Slack cleared this up for me and it&#39;s very straightforward. If you run DFS on T starting from y, you get back all the nodes in T with their preorder and postorder numbers. The nodes on the path from y to z are all of the nodes with a higher postorder number than z AND a lower preorder number than z. Nodes that aren&#39;t on the path from y to z will have a lower postorder number than z OR a higher preorder number than z, but not both. So you can&#39;t do it with just the postorder numbers - you need the postorder numbers AND the preorder numbers.</p>\n<p></p>\n<p>After looking back at Mark Benjamin&#39;s responses above, he mentioned this, but it wasn&#39;t clear to me after the first reading. Also, I just sort of forgot all about preorder numbers, especially after Dr. Vigoda&#39;s comments in the GR1 lectures: &#34;The only application I know of for preorder numbers are to try and trick you on exams&#34;. Got me!!!</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-25T23:36:47Z", 
          "uid": "hq8hn0qyfuvyr", 
          "created": "2017-10-25T23:36:47Z", 
          "type": "feedback", 
          "id": "j97oir1id8p6f9", 
          "anon": "no", 
          "bucket_name": "This week", 
          "config": {}, 
          "bucket_order": 4, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Good post. I was thinking that the problem is you can&#39;t identify the back edge that way to find a complete cycle. However, to solve the problem on the test, you don&#39;t really need the whole cycle.</p>"
        }
      ], 
      "subject": "<p>I&#39;m still confused as to how Explore or DFS <strong><em>without modification</em>\u00a0</strong>can\u00a0return a specific path...\u00a0\u00a0It seems to me that without modification Explore and DFS would return every node in the tree, since they are all connected, and it wouldn&#39;t be clear which nodes were on the path from y to z (i.e. part of the cycle) and which nodes were not on that path.\u00a0 I specifically did not use Explore or DFS for Problem 2 since we were told so explicitly that we could not modify them, though I&#39;m now worried that I might lose points for not using them...\u00a0 I was still able to solve it in\u00a0$$O(n)$$ time (where $$n = |E|$$) with 2 scans of\u00a0the edges in $$T \\cup e$$, but I did not use DFS or Explore.</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-26T14:56:44Z", 
      "d-bucket": "Yesterday", 
      "no_upvotes": 0, 
      "uid": "gy4twfv45cg5o6", 
      "created": "2017-10-26T14:56:44Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j98ldsthxky1h4", 
      "anon": "no", 
      "bucket_name": "Yesterday", 
      "config": {}, 
      "bucket_order": 3, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-26T15:09:09Z", 
          "uid": "hvil6y6khgk2ri", 
          "created": "2017-10-26T15:09:09Z", 
          "type": "feedback", 
          "d-bucket": "Yesterday", 
          "id": "j98ltsbjslmsp", 
          "anon": "no", 
          "bucket_name": "Yesterday", 
          "config": {}, 
          "bucket_order": 3, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>That would be wonderful!</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-26T15:19:07Z", 
          "uid": "ij9b2ekdTWF", 
          "created": "2017-10-26T15:19:07Z", 
          "type": "feedback", 
          "d-bucket": "Yesterday", 
          "id": "j98m6lsrwgy63c", 
          "anon": "no", 
          "bucket_name": "Yesterday", 
          "config": {}, 
          "bucket_order": 3, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>I think that even if none of the pseudocode is modified, just\u00a0pointing out at some point that DFS can be used to identify a particular path would have prevented me from overthinking it on Exam 2 Problem 2.\u00a0 In hindsight, this was touched on in DPV Chapter 3 and it&#39;s implied in the Ford-Fulkerson algorithm, but I just missed it.\u00a0 Maybe touching on it in a HW problem or something would have helped.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-26T15:24:12Z", 
          "uid": "gy4twfv45cg5o6", 
          "created": "2017-10-26T15:24:12Z", 
          "type": "feedback", 
          "d-bucket": "Yesterday", 
          "id": "j98md4rd2b728g", 
          "anon": "no", 
          "bucket_name": "Yesterday", 
          "config": {}, 
          "bucket_order": 3, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "OK, good point.  Thanks for the feedback.  I will make a video talking about using DFS to find a path between connected vertices and point out it&#39;s easy to do if we add this prev[] array to the pseudocode.  --Eric"
        }
      ], 
      "subject": "Thanks all for the good discussion.  I think the best idea (for future iterations of this class) is that I modify the pseudocode of the DFS/BFS algorithms so that it includes the prev[] array to keep track of the &#34;tree edges&#34;, as is done with Dijkstra&#39;s algorithm.  Other thoughts/suggestions?   --Eric"
    }
  ], 
  "nr": 802, 
  "bucket_order": 2, 
  "type": "question", 
  "folders": [
    "graph_algorithms"
  ], 
  "no_answer_followup": 0, 
  "num_favorites": 3, 
  "bucket_name": "Today", 
  "q_edits": [], 
  "data": {
    "embed_links": []
  }, 
  "request_instructor": 0, 
  "tags": [
    "graph_algorithms", 
    "student"
  ], 
  "created": "2017-10-24T12:57:23Z", 
  "is_tag_good": false, 
  "config": {}, 
  "s_edits": [], 
  "my_favorite": false, 
  "default_anonymity": "no", 
  "t": 1509145130628, 
  "tag_good": [], 
  "tag_good_arr": [], 
  "history": [
    {
      "content": "<p>Noobie question here, how can I output the vertices that form cycles in a undirected graph without modifying our class algorithms? Ideally, something like the output of the SCC algo.</p>", 
      "anon": "no", 
      "created": "2017-10-24T12:57:23Z", 
      "uid": "i8597qyse9c1v2", 
      "subject": "Cycles in a undirected graph"
    }
  ]
}