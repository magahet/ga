{
  "status": "active", 
  "unique_views": 153, 
  "request_instructor_me": false, 
  "change_log": [
    {
      "type": "create", 
      "anon": "no", 
      "when": "2017-10-19T02:08:35Z", 
      "data": "j8xtuzrexov5ee", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:10:13Z", 
      "data": "j8xtx3iouuz6tx", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:10:34Z", 
      "data": "j8xtxjj1o0i76d", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:17:09Z", 
      "data": "j8xu60p65e0uw", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:17:24Z", 
      "data": "j8xu6bu4qdx12o", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:21:36Z", 
      "data": "j8xubqxj12235g", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "type": "update", 
      "anon": "no", 
      "when": "2017-10-19T02:22:07Z", 
      "data": "j8xucesn8583l1", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T03:23:26Z", 
      "type": "followup", 
      "uid": "ijarmqggjkc3gz"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T03:32:37Z", 
      "type": "followup", 
      "uid": "hv5exp71kfz754"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T12:44:44Z", 
      "type": "feedback", 
      "uid": "gy4twfv45cg5o6"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T12:50:20Z", 
      "type": "feedback", 
      "uid": "gy4twfv45cg5o6"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T12:56:30Z", 
      "type": "feedback", 
      "uid": "gy4twfv45cg5o6"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T13:01:15Z", 
      "type": "feedback", 
      "uid": "ijarmqggjkc3gz"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T17:41:33Z", 
      "type": "feedback", 
      "uid": "i4jridi579yhq"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T19:50:25Z", 
      "type": "followup", 
      "uid": "hq9zldy4rr4w1"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T21:44:44Z", 
      "type": "feedback", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-19T21:55:49Z", 
      "type": "feedback", 
      "uid": "i4g1simdqek6ey"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-20T03:43:56Z", 
      "type": "followup", 
      "uid": "ijbr5ddtwyt6pa"
    }, 
    {
      "to": "j8xtuzrakpz5ed", 
      "anon": "no", 
      "when": "2017-10-23T15:46:18Z", 
      "type": "followup", 
      "uid": "hq8hn0qyfuvyr"
    }
  ], 
  "upvote_ids": [], 
  "id": "j8xtuzrakpz5ed", 
  "bookmarked": 10, 
  "tags": [
    "graph_algorithms", 
    "student"
  ], 
  "i_edits": [], 
  "is_bookmarked": false, 
  "children": [
    {
      "folders": [], 
      "updated": "2017-10-19T03:23:26Z", 
      "no_upvotes": 0, 
      "uid": "ijarmqggjkc3gz", 
      "created": "2017-10-19T03:23:26Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j8xwj8vxg1p2od", 
      "anon": "no", 
      "bucket_name": "Last week", 
      "config": {}, 
      "bucket_order": 5, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-19T12:44:44Z", 
          "uid": "gy4twfv45cg5o6", 
          "created": "2017-10-19T12:44:44Z", 
          "type": "feedback", 
          "id": "j8ygl35kpqi289", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "For 3.16: the key is that it&#39;s a DAG.   You&#39;re trying to find the length of the longest path in this DAG.\nI think you do it by DP, or at least you can view the algorithm as DP.   Check out Section 4.7 of the book."
        }, 
        {
          "folders": [], 
          "updated": "2017-10-19T13:01:15Z", 
          "uid": "ijarmqggjkc3gz", 
          "created": "2017-10-19T13:01:15Z", 
          "type": "feedback", 
          "id": "j8yh6c02efu1po", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Ok. Spending a little more than a few seconds thinking about it this time... if we run BFS\u00a0on G we visit a vertex (i.e. a course) the first time an edge points to it.\u00a0 This is equivalent to saying\u00a0a student is allowed to take a course as soon as\u00a0one\u00a0prerequisite is completed.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-19T17:41:33Z", 
          "uid": "i4jridi579yhq", 
          "created": "2017-10-19T17:41:33Z", 
          "type": "feedback", 
          "id": "j8yr6t9ae8k34", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>For 3.16 what if, at each iteration, we removed any sinks and then counted the number of iterations until the DAG was empty. The main issue that I see is that it doesn&#39;t use the existing algorithms as a black box.</p>"
        }, 
        {
          "folders": [], 
          "updated": "2017-10-19T21:55:49Z", 
          "uid": "i4g1simdqek6ey", 
          "created": "2017-10-19T21:55:49Z", 
          "type": "feedback", 
          "id": "j8z09s7t2wl4yj", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>Jeff, correct, that is why BFS would not work. I originally thought up that initial solution but did not consider any courses with multiple prerequisites. If there was an additional constraint that each course can only have 1 prerequisite, I believe BFS would work.</p>"
        }
      ], 
      "subject": "<p>Why do you say your solution to 3.16 won&#39;t work?\u00a0 It seems to me BFS should solve this problem.</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-19T03:32:37Z", 
      "no_upvotes": 0, 
      "uid": "hv5exp71kfz754", 
      "created": "2017-10-19T03:32:37Z", 
      "type": "followup", 
      "no_answer": 0, 
      "id": "j8xwv23catd4r5", 
      "anon": "no", 
      "bucket_name": "Last week", 
      "config": {}, 
      "bucket_order": 5, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-19T12:50:20Z", 
          "uid": "gy4twfv45cg5o6", 
          "created": "2017-10-19T12:50:20Z", 
          "type": "feedback", 
          "id": "j8ygsaimori3yx", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "For 3.11, Ethan&#39;s answer up above is a nice one."
        }, 
        {
          "folders": [], 
          "updated": "2017-10-19T12:56:29Z", 
          "uid": "gy4twfv45cg5o6", 
          "created": "2017-10-19T12:56:29Z", 
          "type": "feedback", 
          "id": "j8yh07prfku67u", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "Using back edges for identifying cycles is a good idea too, as Kris is doing.  That definitely finds a cycle.  How do you check that there is a cycle containing (u,v)?  I guess you&#39;re saying run BFS starting from u and look for a back edge that goes back to the start vertex u?   That seems right too, right?"
        }
      ], 
      "subject": "<p>3.11 - I was going to run DFS use post/pre numbers and identify back edges but I like your solution better.\u00a0 DFS visits all the nodes on the graph.\u00a0 Perhaps using explore or BFS(u) with your solution would be faster in some instances.</p>\n<p></p>\n<p>3.16 -\u00a0I think some use of DFS potentially removing sources and sinks iteratively. Not sure how to get it to linear.</p>\n<p></p>\n<p>3.18 - I had the same solution as you.</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-19T19:50:25Z", 
      "no_upvotes": 0, 
      "uid": "hq9zldy4rr4w1", 
      "created": "2017-10-19T19:50:25Z", 
      "type": "followup", 
      "no_answer": 1, 
      "id": "j8yvsj3sv5k785", 
      "anon": "no", 
      "bucket_name": "Last week", 
      "config": {}, 
      "bucket_order": 5, 
      "data": {
        "embed_links": null
      }, 
      "children": [
        {
          "folders": [], 
          "updated": "2017-10-19T21:44:44Z", 
          "uid": "i4g1simdqek6ey", 
          "created": "2017-10-19T21:44:44Z", 
          "type": "feedback", 
          "id": "j8yzvjfp30e6k7", 
          "anon": "no", 
          "bucket_name": "Last week", 
          "config": {}, 
          "bucket_order": 5, 
          "data": {
            "embed_links": null
          }, 
          "children": [], 
          "subject": "<p>I&#39;m not quite sure this will work, but\u00a0I&#39;m having a bit of trouble understanding how you transform that DFS of the reverse binary tree into something that can later be used in constant time. Do you mind going into that?</p>"
        }
      ], 
      "subject": "<p>Would solving 3.18 using a reverse Graph and then finding a path be considered legal? It should take a DFS in linear time\u00a0O( |E| ) from Progeny to ancestors until they match or the search ends.\u00a0</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-20T03:43:56Z", 
      "no_upvotes": 0, 
      "uid": "ijbr5ddtwyt6pa", 
      "created": "2017-10-20T03:43:56Z", 
      "type": "followup", 
      "no_answer": 1, 
      "id": "j8zcph5z26urq", 
      "anon": "no", 
      "bucket_name": "Last week", 
      "config": {}, 
      "bucket_order": 5, 
      "data": {
        "embed_links": null
      }, 
      "children": [], 
      "subject": "<p>For 3.16, wouldn&#39;t you want to run BPF on the reverse graph instead of G? That way, you get all paths to n (which covers cases where there are multiple prerequisites). So, say I need math and reading before I can take programming. Both math and reading would point to programming, but it would not cover that you need both, so you may miss something.\u00a0</p>\n<p></p>\n<p>Generate G&#96; which is the reverse of G</p>\n<p>max_sems = 0<br />for each n in courses:</p>\n<p>\u00a0 \u00a0s = BFS(G&#96;, n)</p>\n<p>\u00a0 \u00a0if s &gt; max_sems then max_sems = s</p>\n<p>Now max_sems is the maximum number, and it includes cases where there are multiple prerequisites, as it searches in the opposite direction.</p>\n<p><br />So O(n*(V&#43;E))</p>\n<p><br />That make sense, or am I missing something?</p>"
    }, 
    {
      "folders": [], 
      "updated": "2017-10-23T15:46:18Z", 
      "no_upvotes": 0, 
      "uid": "hq8hn0qyfuvyr", 
      "created": "2017-10-23T15:46:18Z", 
      "type": "followup", 
      "no_answer": 1, 
      "id": "j94cu04n77z5v3", 
      "anon": "no", 
      "bucket_name": "Today", 
      "config": {}, 
      "bucket_order": 2, 
      "data": {
        "embed_links": null
      }, 
      "children": [], 
      "subject": "3.16 was tough.\n\nDefine &#34;height&#34; to be the number of semesters before graduation that the course must be taken, at the latest.\n\nRun DFS on G to produce postorder numbers. For each vertex u in order of increasing postorder numbers, the height is given by\n\th(u) = 1 &#43; max(0, h(v)) | (u,v) is an edge in G\n\t\nThe answer is then max(h(u)) | u is any vertex.\n\nWhat we&#39;re doing, approximately, is starting with the courses that are not prerequisites for any other course, assigning them to the last semester, then working our way backwards through the depedencies, always assigning courses to the last semesters in which they can be taken. Because we&#39;re working in the reverse of the linearized order, each time we&#39;re calculating the height for a course, we have the answers for the dependent courses so that we can do the calculation.\n\nNice problem. I spun my wheels a long time on it, though, before reading Dr. Vigoda&#39;s hint and looking at the textbook."
    }
  ], 
  "nr": 756, 
  "bucket_order": 2, 
  "type": "note", 
  "folders": [
    "graph_algorithms"
  ], 
  "no_answer_followup": 3, 
  "num_favorites": 5, 
  "bucket_name": "Today", 
  "q_edits": [], 
  "data": {
    "embed_links": []
  }, 
  "request_instructor": 0, 
  "created": "2017-10-19T02:08:35Z", 
  "is_tag_good": false, 
  "config": {}, 
  "s_edits": [], 
  "my_favorite": false, 
  "default_anonymity": "no", 
  "t": 1509145138004, 
  "tag_good": [], 
  "tag_good_arr": [], 
  "history": [
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I\u00a0recognize this will not work, but I welcome any other ideas. It was a little weird to me\u00a0without modifying the algorithms. A linear solution may not be possible without modification. Here are my thoughts. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by BFS\u00a0. You may have to subtract 1 if BFS\u00a0depth starts at 1 to account for the super source. BFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:22:07Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I\u00a0recognize this will not work, but I welcome any other ideas. It was a little weird to me\u00a0without modifying the algorithms. Here are my thoughts. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by BFS\u00a0. You may have to subtract 1 if BFS\u00a0depth starts at 1 to account for the super source. BFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:21:36Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I don&#39;t think this will work but welcome any other ideas. It was a little weird to me\u00a0without modifying the algorithms. But here are my thoughts. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by BFS\u00a0. You may have to subtract 1 if BFS\u00a0depth starts at 1 to account for the super source. BFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:17:24Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I don&#39;t think this will work but welcome any other ideas since DFS may find the shorter path to a class instead of the longest. It was a little weird to me\u00a0without modifying the algorithms. But here are my thoughts. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by BFS\u00a0. You may have to subtract 1 if BFS\u00a0depth starts at 1 to account for the super source. BFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:17:09Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I think this will work. It was a little weird to me\u00a0without modifying the algorithms. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by BFS\u00a0. You may have to subtract 1 if BFS\u00a0depth starts at 1 to account for the super source. BFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:10:34Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p></p>\n<p>I think this will work. It was a little weird to me\u00a0without modifying the algorithms. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by DFS. You may have to subtract 1 if DFS depth starts at 1 to account for the super source. DFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:10:13Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }, 
    {
      "content": "<p>I was working some practice problems, and I wanted to post my solutions to see if other people disagree with my solutions or have a better solution. I tried solving these without modifying the algorithms and using the algorithms as specified in the lecture videos.</p>\n<p></p>\n<p><strong>[3.11] Design a linear-time algorithm which, given an\u00a0undirected graph $$G=(V,E)$$ and an edge $$e \\in E$$, determines whether $$G$$ has a cycle containing $$e$$.</strong></p>\n<p></p>\n<p>Let $$e=(u,v)$$. Remove $$e$$ from the $$G$$ and run DFS to determine connected components (the first DFS mentioned in lecture). If $$u$$ and $$v$$ are in the same connected component, they $$e$$ is part of a cycle.</p>\n<p></p>\n<p><strong>[3.16] Suppose a CS curriculum consists of $$n$$ courses, all of them mandatory. The prerequisite graph $$G$$ has a node for each course, and an edge from course $$v$$ to course $$w$$ if and only if $$v$$ is a prerequisite for $$w$$. Find an algorithm\u00a0that works directed with this graph representation, and computes the minimum number of semesters necessary to complete the curriculum (assume a student can take any number of courses in one semester). The running time of your algorithm should be linear.</strong></p>\n<p><strong></strong></p>\n<p>I think this will work. It was a little weird to me\u00a0without modifying the algorithms. First intuition is to use DFS, but DFS does not output any concept of depth. Instead use\u00a0BFS on $$G$$. BFS, as specified by Lecture MF4, inputs\u00a0$$G=(V,E)$$ and starting vertex $$s \\in V$$ and outputs the distance for each vertex. We can let $$s$$ be a super source vertex that has an edge to each source in $$G$$. The minimum number of semesters\u00a0required is equal to max distance returned by DFS. You may have to subtract 1 if DFS depth starts at 1 to remove the super source. DFS runs in linear time.</p>\n<p></p>\n<p><strong>[3.18] You are given a binary tree $$T=(V,E)$$ (in adjacency list format), along with a designated root node $$r \\in E$$. Recall that $$u$$ is said to be an ancestor of $$v$$ in the rooted tree, if the path from $$r$$ to $$v$$ in $$T$$ passes through $$u$$. You wish to preprocess the tree so that queries of the form &#34;is $$u$$ an ancestor of $$v$$ can be answered inc constant time. The preprocessing itself should take linear time. How can this be done?</strong></p>\n<p></p>\n<p>Make use of the preorder and postorder numbers to do this. Run DFS starting from $$r$$ (hopefully we are allowed to specify a start location for test) to get preorder and postorder. You can store the preorder and postnumber in your favorite O(1) lookup data structure. When you actually need to query, $$u$$ is an ancestor of $$v$$ if the following two conditions are met: (1) $$pre(u) &lt; pre(v)$$ and (2) $$ post(u) &gt; post(v)$$.\u00a0</p>", 
      "anon": "no", 
      "created": "2017-10-19T02:08:35Z", 
      "uid": "i4g1simdqek6ey", 
      "subject": "DPV 3.11, 3.16, 3.18"
    }
  ]
}